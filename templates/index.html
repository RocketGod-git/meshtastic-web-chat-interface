<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Meshtastic Web Interface</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Meshtastic Web Interface</h1>
        <div class="row">
            <div class="col-md-4">
                <div class="form-group">
                    <label for="portSelect">Select COM Port:</label>
                    <select class="form-control" id="portSelect">
                        {% for port in ports %}
                            <option value="{{ port }}">{{ port }}</option>
                        {% endfor %}
                    </select>
                </div>
                <button class="btn btn-primary" id="connectBtn">Connect</button>
                <button class="btn btn-danger" id="disconnectBtn" disabled>Disconnect</button>
            </div>
            <div class="col-md-8">
                <div class="form-group">
                    <label for="messageInput">Message:</label>
                    <input type="text" class="form-control" id="messageInput" placeholder="Enter message">
                </div>
                <div class="form-group">
                    <label for="channelSelect">Select Channel:</label>
                    <select class="form-control" id="channelSelect"></select>
                </div>
                <button class="btn btn-success" id="sendBtn" disabled>Send Message</button>
            </div>
        </div>
        <hr>
        <div class="row">
            <div class="col-md-6">
                <h2>Messages</h2>
                <div id="messagesContainer" style="height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px;"></div>
            </div>
            <div class="col-md-6">
                <h2>Node Information <span id="nodeCount"></span></h2>
                <div id="nodeInfo" style="height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px;"></div>
            </div>
        </div>
        <hr>
        <h2>Debug Window</h2>
        <div id="debugWindow" style="height: 200px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px;"></div>
    </div>

    <script>
$(document).ready(function() {
    var socket = io();
    var currentChannel = 0;
    var nodes = {};
    var messages = {};

    function logDebugMessage(message) {
        var debugWindow = $('#debugWindow');
        var timestamp = new Date().toLocaleString();
        debugWindow.append('<p>[' + timestamp + '] ' + message + '</p>');
        debugWindow.scrollTop(debugWindow[0].scrollHeight);
        console.log('[DEBUG] ' + message);
    }

    function updateNodeInfo() {
        var nodeCount = Object.keys(nodes).length;
        $('#nodeCount').text(`(${nodeCount})`);
        
        var nodeInfoContainer = $('#nodeInfo');
        nodeInfoContainer.empty();
        Object.values(nodes).sort((a, b) => (b.lastHeard || 0) - (a.lastHeard || 0)).forEach(function(node) {
            var nodeName = (node.user.longName || '') + (node.user.shortName ? ` (${node.user.shortName})` : '');
            if (!nodeName.trim()) nodeName = node.num;
            
            var nodeHtml = '<div class="card mb-2">' +
                        '<div class="card-body">' +
                        '<h5 class="card-title">' + nodeName + '</h5>' +
                        '<p class="card-text">' +
                        '<strong>ID:</strong> ' + node.num + '<br>' +
                        '<strong>User ID:</strong> ' + (node.user.id || 'N/A') + '<br>' +
                        '<strong>Mac Address:</strong> ' + (node.user.macaddr || 'N/A') + '<br>' +
                        '<strong>Hardware Model:</strong> ' + (node.user.hwModel || 'N/A') + '<br>' +
                        '<strong>Role:</strong> ' + (node.user.role || 'N/A') + '<br>' +
                        '<strong>Licensed:</strong> ' + (node.user.isLicensed ? 'Yes' : 'No') + '<br>' +
                        '<strong>Last Heard:</strong> ' + (node.lastHeard ? new Date(node.lastHeard * 1000).toLocaleString() : 'N/A') + '<br>' +
                        '<strong>SNR:</strong> ' + (node.snr !== undefined ? node.snr.toFixed(2) : 'N/A') + '<br>' +
                        '<strong>Hops Away:</strong> ' + (node.hopsAway !== undefined ? node.hopsAway : 'N/A') + '<br>';
            
            if (node.position && (node.position.latitude !== undefined || node.position.latitudeI !== undefined)) {
                var lat = node.position.latitude || (node.position.latitudeI / 1e7);
                var lon = node.position.longitude || (node.position.longitudeI / 1e7);
                nodeHtml += '<strong>Position:</strong><br>' +
                            '&nbsp;&nbsp;Latitude: ' + lat.toFixed(7) + '<br>' +
                            '&nbsp;&nbsp;Longitude: ' + lon.toFixed(7) + '<br>' +
                            '&nbsp;&nbsp;Altitude: ' + (node.position.altitude !== undefined ? node.position.altitude + 'm' : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Time: ' + (node.position.time ? new Date(node.position.time * 1000).toLocaleString() : 'N/A') + '<br>';
            }
            
            if (node.deviceMetrics) {
                nodeHtml += '<strong>Device Metrics:</strong><br>' +
                            '&nbsp;&nbsp;Battery Level: ' + (node.deviceMetrics.batteryLevel !== undefined ? node.deviceMetrics.batteryLevel + '%' : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Voltage: ' + (node.deviceMetrics.voltage !== undefined ? node.deviceMetrics.voltage.toFixed(3) + 'V' : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Channel Utilization: ' + (node.deviceMetrics.channelUtilization !== undefined ? node.deviceMetrics.channelUtilization.toFixed(2) : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Air Utilization TX: ' + (node.deviceMetrics.airUtilTx !== undefined ? node.deviceMetrics.airUtilTx.toFixed(2) : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Uptime: ' + (node.deviceMetrics.uptimeSeconds !== undefined ? formatUptime(node.deviceMetrics.uptimeSeconds) : 'N/A') + '<br>';
            }

            if (node.telemetry && node.telemetry.deviceMetrics) {
                nodeHtml += '<strong>Telemetry:</strong><br>' +
                            '&nbsp;&nbsp;Time: ' + (node.telemetry.time ? new Date(node.telemetry.time * 1000).toLocaleString() : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Battery Level: ' + (node.telemetry.deviceMetrics.batteryLevel !== undefined ? node.telemetry.deviceMetrics.batteryLevel + '%' : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Voltage: ' + (node.telemetry.deviceMetrics.voltage !== undefined ? node.telemetry.deviceMetrics.voltage.toFixed(3) + 'V' : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Channel Utilization: ' + (node.telemetry.deviceMetrics.channelUtilization !== undefined ? node.telemetry.deviceMetrics.channelUtilization.toFixed(2) : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Air Utilization TX: ' + (node.telemetry.deviceMetrics.airUtilTx !== undefined ? node.telemetry.deviceMetrics.airUtilTx.toFixed(2) : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Uptime: ' + (node.telemetry.deviceMetrics.uptimeSeconds !== undefined ? formatUptime(node.telemetry.deviceMetrics.uptimeSeconds) : 'N/A') + '<br>';
            }

            if (node.telemetry && node.telemetry.environment) {
                nodeHtml += '<strong>Environment:</strong><br>' +
                            '&nbsp;&nbsp;Temperature: ' + (node.telemetry.environment.temperature !== undefined ? node.telemetry.environment.temperature.toFixed(1) + '°C' : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Relative Humidity: ' + (node.telemetry.environment.relativeHumidity !== undefined ? node.telemetry.environment.relativeHumidity.toFixed(1) + '%' : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Barometric Pressure: ' + (node.telemetry.environment.barometricPressure !== undefined ? node.telemetry.environment.barometricPressure.toFixed(1) + ' hPa' : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Gas Resistance: ' + (node.telemetry.environment.gasResistance !== undefined ? node.telemetry.environment.gasResistance.toFixed(1) + ' Ω' : 'N/A') + '<br>' +
                            '&nbsp;&nbsp;Satellite Count: ' + (node.telemetry.environment.satelliteCount !== undefined ? node.telemetry.environment.satelliteCount : 'N/A') + '<br>';
            }
            
            nodeHtml += '</p></div></div>';
            nodeInfoContainer.append(nodeHtml);
        });
        logDebugMessage('Node information updated');
    }

    function formatUptime(seconds) {
        var days = Math.floor(seconds / (3600*24));
        var hours = Math.floor(seconds % (3600*24) / 3600);
        var minutes = Math.floor(seconds % 3600 / 60);
        var secs = Math.floor(seconds % 60);

        var parts = [];
        if (days > 0) parts.push(days + 'd');
        if (hours > 0) parts.push(hours + 'h');
        if (minutes > 0) parts.push(minutes + 'm');
        if (secs > 0) parts.push(secs + 's');

        return parts.join(' ');
    }

    function updateMessages() {
        var messagesContainer = $('#messagesContainer');
        messagesContainer.empty();
        if (messages[currentChannel]) {
            messages[currentChannel].forEach(function(msg) {
                var messageText;
                var statusDot = msg.sender === 'You' ? 
                    (msg.status === 'pending' ? '🟡' : (msg.status === 'acked' ? '🟢' : '🔴')) : '🟢';
                if (msg.sender === 'You') {
                    messageText = `${statusDot} <strong>You:</strong><br>${msg.text}<br><small>${new Date(msg.timestamp * 1000).toLocaleString()} (ID: ${msg.packetId})</small>`;
                } else {
                    messageText = `${statusDot} ${msg.formatted_message || `<strong>${msg.sender}:</strong><br>${msg.text}<br><small>${new Date(msg.timestamp * 1000).toLocaleString()}</small>`}`;
                }
                messagesContainer.append('<p>' + messageText + '</p><hr>');
            });
        }
        messagesContainer.scrollTop(messagesContainer[0].scrollHeight);
        logDebugMessage('Messages updated for channel ' + currentChannel);
    }

    function updateChannelList(channels) {
        var channelSelect = $('#channelSelect');
        channelSelect.empty();
        channels.forEach(function(channel) {
            if (channel.index === 0 || channel.name) {
                channelSelect.append($('<option>', {
                    value: channel.index,
                    text: channel.index === 0 ? 'PRIMARY' : channel.name
                }));
            }
        });
        logDebugMessage('Channel list updated');
    }

    $('#connectBtn').click(function() {
        var selectedPort = $('#portSelect').val();
        if (!selectedPort) {
            logDebugMessage('Error: No port selected');
            alert('Please select a port before connecting.');
            return;
        }
        socket.emit('connect_serial', { port: selectedPort });
        logDebugMessage('Attempting to connect to port: ' + selectedPort);
    });

    $('#disconnectBtn').click(function() {
        socket.emit('disconnect_serial');
        logDebugMessage('Attempting to disconnect from serial port');
    });

    $('#messageInput').keypress(function(e) {
        if (e.which == 13) { 
            e.preventDefault(); 
            $('#sendBtn').click(); 
        }
    });

    $('#sendBtn').click(function() {
        var message = $('#messageInput').val().trim();
        if (message) {
            socket.emit('send_message', { message: message, channel: currentChannel });
            logDebugMessage('Sending message: "' + message + '" on channel ' + currentChannel);
            $('#messageInput').val(''); 
        } else {
            logDebugMessage('Error: Empty message');
            alert('Please enter a message before sending.');
        }
    });

    $('#channelSelect').change(function() {
        currentChannel = parseInt($(this).val());
        updateMessages();
        logDebugMessage('Switched to channel: ' + currentChannel);
    });

    socket.on('connect', function() {
        logDebugMessage('Socket.IO connected to server');
    });

    socket.on('disconnect', function() {
        logDebugMessage('Socket.IO disconnected from server');
    });

    socket.on('serial_connected', function(data) {
        logDebugMessage('Serial connected: ' + JSON.stringify(data));
        $('#connectBtn').prop('disabled', true);
        $('#disconnectBtn').prop('disabled', false);
        $('#sendBtn').prop('disabled', false);
    });

    socket.on('serial_disconnected', function() {
        logDebugMessage('Serial disconnected');
        $('#connectBtn').prop('disabled', false);
        $('#disconnectBtn').prop('disabled', true);
        $('#sendBtn').prop('disabled', true);
        $('#channelSelect').empty();
        $('#messagesContainer').empty();
        $('#nodeInfo').empty();
        nodes = {};
        messages = {};
    });

    socket.on('serial_error', function(data) {
        logDebugMessage('Serial error: ' + JSON.stringify(data));
        alert('Serial error: ' + data.message);
    });

    socket.on('channel_list', function(data) {
        logDebugMessage('Channel list received: ' + JSON.stringify(data));
        updateChannelList(data.channels);
    });

    socket.on('new_message', function(data) {
        logDebugMessage('New message received: ' + JSON.stringify(data));
        var messageData = data.raw_message || data;
        if (!messageData || typeof messageData.channel === 'undefined') {
            logDebugMessage('Error: Invalid message format');
            return;
        }
        if (!messages[messageData.channel]) {
            messages[messageData.channel] = [];
        }
        if (messageData.sender === 'You') {
            messageData.status = 'pending';
        }
        messages[messageData.channel].push(messageData);
        if (messageData.channel === currentChannel) {
            updateMessages();
        }
    });

    socket.on('message_sent', function(data) {
        if (data.status === 'success') {
            logDebugMessage('Message sent successfully');
        } else {
            logDebugMessage('Error sending message: ' + data.message);
        }
    });

    socket.on('node_updated', function(data) {
        logDebugMessage('Node updated: ' + JSON.stringify(data));
        if (!data.num && !data.user.id) {
            logDebugMessage('Error: Invalid node data');
            return;
        }
        var nodeId = data.num || data.user.id;
        nodes[nodeId] = data;
        updateNodeInfo();
    });

    socket.on('message_ack', function(data) {
        logDebugMessage('ACK received for packet ID: ' + data.packetId);
        updateMessageStatus(data.packetId, 'acked');
    });

    socket.on('message_ack_timeout', function(data) {
        logDebugMessage('ACK timeout for packet ID: ' + data.packetId);
        updateMessageStatus(data.packetId, 'timeout');
    });

    function updateMessageStatus(packetId, status) {
        Object.keys(messages).forEach(function(channel) {
            messages[channel].forEach(function(msg) {
                if (msg.packetId === packetId) {
                    msg.status = status;
                    logDebugMessage('Message status updated to ' + status + ' for packet ID: ' + packetId);
                }
            });
        });
        updateMessages();
    }

    socket.on('all_messages', function(data) {
        logDebugMessage('All messages received: ' + JSON.stringify(data));
        messages = {};
        if (Array.isArray(data.messages)) {
            data.messages.forEach(function(msg) {
                if (!messages[msg.channel]) {
                    messages[msg.channel] = [];
                }
                messages[msg.channel].push(msg);
            });
            updateMessages();
        } else {
            logDebugMessage('Error: Invalid messages data');
        }
    });

    try {
        {% if channels %}
            updateChannelList({{ channels|tojson }});
        {% else %}
            logDebugMessage('No initial channel data available');
        {% endif %}

        {% if nodes %}
            {% for node in nodes %}
                nodes[{{ node.num }}] = {{ node|tojson }};
            {% endfor %}
            updateNodeInfo();
            logDebugMessage('Nodes populated: ' + Object.keys(nodes).length);
        {% else %}
            logDebugMessage('No initial node data available');
        {% endif %}
    } catch (error) {
        console.error('Error in initial data population:', error);
        logDebugMessage('Error populating initial data: ' + error.message);
    }
});
    </script>
</body>
</html>
